Create an Express.js Server
*   What is Express.js?
        Think back to your time spend working with server-side APIs. Whenever you needed to retrieve data from an API, you would make a request to an endpoint. 
        After a short period of time, the server would return the data to the client in the form of a response. Express.js follows a similar pattern. 

*   What's a server?
        To be considered a server, a machine or program needs to provide some functionatlity to a client. 
        In our case, we want that functionality to be accepting a request and sending back a response. 
        Node.js has built-in libraries that support this functionality, but writing Node.js servers requries significantly more code than using Express.js to do the job. 

*   The first thing we'll do is set up the server so that it's listening for incoming requests. Start by installing Express.js by running the following commands:
        npm init -y //Starts the npm intitialization process and the -y flag is being used to skip the package questionaire and leave defaults. 
        npm i express //You can use npm i as a shortcut for npm install

*   Setting up the server with the server.js file
        Just like any other npm package, we will require Express.js at the top of the file. Add the following code to the top of the file:
            const express = require('express');

        Setting up the server only takes two steps: we need to instantiate the server, then tell it to listen for requres. To instantiate the server, add the following code to server.js:
            const app = express;
                This is all it takes to start Express.js. We assign express() to the app variable so that we can later chain on methods to the Express.js server. 
                Now we just need to use one method to make our server listen. 
                We're going to chain the listen() method onto our server to do it. To do that, add the following code to the end of server.js:

                    app.listen(3001, () => {
                        console.log('API server now on port 3001!');
                    });

                To start the server, use the following command:
                    npm start

*   What's a port?
        To understand ports, let's make an analogy.
            Imagine that a website is like a college campus. A website has an address, referred to as the host. A college campus also has an address.
                The host tells the client where to go, but it doesn't specify exactly where to go. 
                Likewise, if you have the address of the college campus, you don't know exactly which building or classrom to go to.
                The port is lika a building/classroom; it gives the exact destination on the host. 

        If you're browsing the internet, chances are you're visiting the address on one of two ports: 80 or 443.
            80 is typically used for sites that begin with http://, and 443 is used for sites that begin with https://.
            This raises the question: Why are we using 3001 instead of 80 or 443?
                The truth is, there's nothing wrong with running your server on 80 or 443. 
                However, ports with numbers 1024 and under are considered special by the operating system, and often require special permissions (like running the process as an admin.)
                    To avoid these permission restrictions, we chose to run on a poart thit is less restircted, which in this case is 3001, but there are plentys of others available.
                        Port numbers can range from 1024 to 49151!
                            We chose a number around 3000 because it is common practice and farily easy to remember. 


Handle Requests for Animals (data)
*   Let's start by creating a route that the front-end can request data from. Starting by requireing the data by adding the following code at the top of server.js:
        const { animals } = require('./data/animals)
    To add a route, type the following code just before app.listen():
        app.get('/api/animals', (req, res) => {
            res.send('Hello!');
        });
    There are two important takeways from this code:
        1.The first is that the get() method requires two arguments. The first is a string that describes the route the client will have to fetch from.
            The second callback function that will execute every time that route is access with a GET request. 
        2. The second takeaway is that we are using the send() method from the res parameter (short for response) to send the string Hello! to our client. 
    The send() method is great if we want to send short messages, but what if we want to send lots of JSON, like we've seen from APIs? To send JSON, just change send to json.
        We do this to change the headers (i.e., additional metatdata that's sent with every request/response) so that the client know's it's receiving JSON.

    Now we will update the code to use res.json() by changing the second lin in the following code block from res.send('Hello!'); to res.json(animals);:
        app.get('/api/animals', (req, res) => {
            res.json(animals);
        });
            By running the server, the animals.json file would appear at the url http://localhost:3001/api/animals
                There is not a ton of data here, but what if we need info about 5 gorillas and they had 300 animals?
                    Do you remember when you worked with serverside APIs that you were able to specify parameters with your query by using ? or :<parameter>? 
                        Now we are going to create that same functionality with our own server. 
                            To create this query, we'll add another function called filterByQuery().
                                This is going to help us handle differnt kinds of queries. 
                                We will start by extracting the data from after the question mark.
                                    This time we will use the req paramer, which is short for "request" 
                                    Whatever string of query parameters you use on the URL will become JSON, so ?a=111&b=222&c=333 will become:
                                        {
                                            a: "111",
                                            b: "222",
                                            c: "333"
                                        }
                                    Importatnly, if you repeat the same query name with different values, it will become an array in the JSON. So, ?a=111&b=222&b=333 would become:
                                        {
                                            a: "111",
                                            b: ["222", "333"]
                                        }
                                    With that in mind, instead of handling the filter functionatlity inside the .get() callback, we're going to break it out into its own function. 
                                        This will keep our code maintainable and clean. Above the.get(), create a new function called filterByQuery() by adding the following code:
                                            function filterByQuery(query, animalsArray) {
                                                let filteredResults = animalsArray;
                                                if (query.diet) {
                                                    filteredResults = filteredResults.filter(animal => animal.diet === query.diet);
                                                }
                                                if (query.species) {
                                                    filteredResults = filteredResults.filter(animal => animal.species === query.species);
                                                }
                                                if (query.name) {
                                                    filteredResults = filteredResults.filter(animal => animal.name === query.name);
                                                }
                                                return filteredResults;
                                            }
                                        This function will take in re.query as an argument and filter through the animals accordingly returning the new filtered array. 
                                        Go ahead and call the filterByQuery() in the app.get() callback as shown in the following code:
                                            app.get('/api/animals', (req, res) => {
                                                let results = animals;
                                                if (req.query) {
                                                    results = filterByQuery(req.query, results);
                                                }
                                                res.json(resulsts);
                                            });
                                        This code works well querying properties that are strings, but what if we wanted to filter out animals based on their personality traits?
                                            This is different because the personality traits are within an array. To make things more complex, users migh want to filter animals by multipe personality traits at the samte time.
                                                This means we'll have to handle query.personalityTraits differently from the way we handle the other queries. 
                                            How does this process differ from querying for one verus mutliple personality traits?
                                                Adding &personalityTraits=quirky&personalityTraits=rash to the end of the URL in the browser will cause req.query.personalityTraits to become the following array: ['quirky', 'rash'].
                                                However, if we were to query by only one personality trait, like personalityTraits=rash, then req.query.personalityTraits would be the string rash. 
                                                To combat this, modify the filterByQuery() function to handle both cases by adding the following code:
                                                    function filterByQuery(query, animalsArray) {
                                                    let personalityTraitsArray = [];
                                                    // Note that we save the animalsArray as filteredResults here:
                                                    let filteredResults = animalsArray;
                                                    if (query.personalityTraits) {
                                                        // Save personalityTraits as a dedicated array.
                                                        // If personalityTraits is a string, place it into a new array and save.
                                                        if (typeof query.personalityTraits === 'string') {
                                                        personalityTraitsArray = [query.personalityTraits];
                                                        } else {
                                                        personalityTraitsArray = query.personalityTraits;
                                                        }
                                                        // Loop through each trait in the personalityTraits array:
                                                        personalityTraitsArray.forEach(trait => {
                                                        // Check the trait against each animal in the filteredResults array.
                                                        // Remember, it is initially a copy of the animalsArray,
                                                        // but here we're updating it for each trait in the .forEach() loop.
                                                        // For each trait being targeted by the filter, the filteredResults
                                                        // array will then contain only the entries that contain the trait,
                                                        // so at the end we'll have an array of animals that have every one 
                                                        // of the traits when the .forEach() loop is finished.
                                                        filteredResults = filteredResults.filter(
                                                            animal => animal.personalityTraits.indexOf(trait) !== -1
                                                        );
                                                        });
                                                    }
                                                    if (query.diet) {
                                                        filteredResults = filteredResults.filter(animal => animal.diet === query.diet);
                                                    }
                                                    if (query.species) {
                                                        filteredResults = filteredResults.filter(animal => animal.species === query.species);
                                                    }
                                                    if (query.name) {
                                                        filteredResults = filteredResults.filter(animal => animal.name === query.name);
                                                    }
                                                    // return the filtered results:
                                                    return filteredResults;
                                                    }
                                                See the comments in the code. We're revising the filterReulsts array for each trait that we loop through with .forEach().
                                                    Each iteration revises filteredResults to that it only contains animals that possess the indicated trait. 
                                                    At the end of the .forEach() loop, we'll have a filteredResults array that only contains animals that have all the traits we're targeting. 
                                                        Also, while comments may extent the length of your code, they increase its maintainability, not only by you, but by anyone who has to maintain your code going forward. 
                                                        Don't be afraid to add comments to clarify a routine that was tricky to write. 
                                                Now, the filterByQuery() method ensures that query.personalityTraits is always an array before the .forEach() method executes.        

    
Deploy to Heroku
*   We're ready to deploy our application, but we have one problem. GitHub Pages only deploys static sites made up of HTML pages, but we we need to deploy a server.js file that is going to run a Node.js process.
        Therfore, we'll need to use Heroku.
    To get started, created a Heroku account at Heroku.com. Then download the Heroku CLI. The CLI will help us easily get our app deployed, and we won't even need to leave the command line!
    To create a new Heroku application, enter the following command into the terminal:
        heroku create
            You can specify the name of your application by adding <app-name> after heroku create, but it must be a unique name that isn't used anywhere else on Heroku. 
    Just as with GitHub Pages, the deployment steps rely on a Git branch. Reather than pushing to origin main though, we will push to heroku main, as this is a new location for our repository's code to go.
        When we say origin or heroku in our git push commands, they are what's known as the "remote".
        Unfortunately, we cannot simply say git push heroku main when we aren't current in the local main branch.
            Heroku doesn't allow for cross-branch actions the same way GitHub allows. 
                This is a good problem to have, though, as typically we would never want to deploy code to production from a working feature branch. 
                Run the following commands from the command line:
                    git add .
                    git commit -m "Add Heroku"
                    git push heroku main (only if you are currently in main branch)
                        However if you in a different branch it would be:
                            git push heroku <current_git_hub_branch>:main
                Now open the newly created app using the output from the command line in the browser. There will be two items that look like lins, the one we want to open in the browser is the that one that says <your-app-nam>herokuapp.com and not the one that ends with .git
                You can also open the application by entering heroku open from the command line!
                You should receive an Application error! 
                    This happened because we used the hardcoded port of 3001. Heroku apps get server using port 80. We could hardcode our app to use 80, but instead we are going to tell our app to use an environment variable. 
                    When Heroku runs our app, it sets an enviroment variable called process.env.PORT. We're going to tell our app to use that port, if it has been set, and if not, default to port 80.
                        Application served over Heroku as well as most hosts must run on port 80. If the host uses HTTPS, then the port would be set to 443.
                        In server.js, add the following line of code before const app:
                            const PORT = process.env.PORT || 3001;
                                Now go down to where we have our application listening, and replace the hardcoded value with the PORT variable like so:
                                   app.listen(PORT, () => {
                                        console.log(`API server now on port ${PORT}!`);
                                    });

Handle Requests for a Specific Animal (Piece of data)
*   Sometimes we only want one specific animal, rather than an array of all the animals that match a query.
        The req object gives us access to another property for this case, req.params.
        Unlike the query object, the param object needs to be defined in the route path, with <route>/:<parameterName>
        For our sake, create a new GET route for anaimals, after the first Get all route, this time adding :id to the end of the route, as shown in the following code:
            app.get('/api/animals/:id', (req, res) => {
                const result = findById(req.params.id, animals);
                    res.json(result);
            });
        Now that we have multiple routes, we have to pay extra attention to the order of the routes. 
            A param route must come after the other GET route. 
            You may have already noticed that ther's a function called findById() in the callback that looks just like filterByQuery(), except this time we're passing req.params.id.
            Why don't we just use the filterByQuery() function from earlier?
                Well, we could, but we know for certian that this route should only return a single animal, because the id is unique. 
                We also know that there won't be any query on a single animal, so there's no need for all of the other code. 
            Above the two routes, add a function called findById() that takes in the id and array of animals and returns a single animal object, as shown in the following code:
                function findById(id, animalsArray) {
                    const result = animalsArray.filter(animal => animal.id === id)[0];
                    return result;
                }
            Restart your local server with npm start. Then navigate to http://localhost:3001/api/animals/1
                This time, the JSON response is a single object instead of an array. 
                Now let's return to the id route and update it so that if no record exists for the animal being searched for, the client receives a 404 error.
                    Remember that the 404 status code is meant to communicate to the client that the requested resource could not be found.
                    To send this error, we can just send the 404 error code with res.send() like this:
                        app.get('/api/animals/:id', (req, res) => {
                            const result = findById(req.params.id, animals);
                            if (result) {
                                res.json(result);
                            } else {
                                res.send(404);
                            }
                        });
                    We chose to return an error here instead of an empty object or undefined in order to make it clear to the client that the resource they asked for, in this case a specific animal, does not exist. 
                    Note that this is a fairly common practice, but some developer teams might choose other errors to send back to the client, or no error at all.
                    Restart the localhost, and then test the site for 404 functionality by supplying nonsensical IDs, and also check to ensure that actual IDs produce the expected output.
                What is the appropriate use case for req.param vs. req.query?
                    req.query is multifaceted, often combining multiple parameters, whereas req.param is specific to a single property, often intended to retrieve a single record.

Add POST Route to Animals Endpoint (Allows us to create an animal)
*   GET Routes are probably the most common request a developer makes to a server, as we constantly need data to populate the client-side of our web application so users can interact with it. 
    In fact, there are a number of APIs that developers use on a regular basis that only have GET request capabilities.
        So if GET requests serve the purpose of retrieving data from a server and sending it back to the client, how does that get stored on the server in the first place?
        Typically, this is accomplished in one of two ways:
            1. The developer team populates the server with the data manually, because they have access to the server code. 
            2. Users of the app populate the server with data by sending data from the client side of the application to the server. 
                The first way doesn't allow for the type of user interaction that this application requires, so let's take a look at how the second way works. 
                First, we'll set up a route on our server that accepts data to be used or stored server-side.
                    In server.js, add the following code below the two GET routes you've created:
                        app.post('/api/animals', (req, res) => {});
                    Notice that this is just another method of the app object that allows us to create routes, much lik app.get(). 
                        This method doesn't say get though, it says post, which means that we defined a route that listens for POST requests, not GET request. 
                        POST requests differ from GET requests in that they represent the action of a client requesting the server to accept data rather than vice versa. 
                    Also notice the route nbame, /api/animals. Aren't we already using that for a GET request? How does it know which route to use when a request is made?
                        It'll know because of how we form the request. We haven't created a POST request just yet, but think about how we've made GET requests in the past:
                            We make a GET request every time we enter a URL into the browser and press the Enter key to see what will come back in response. 
                                The most common responses we'll see from this is usually JSON - as we've seen already- or a webpage, which we'll see soon.
                            When we use the Fetch API, its defualt request method is GET, as we've seen and used previously. 
                    When we make any type of request to the server, Express.js will go through a couple different phases. 
                        First, it'll take the URL we made a request to and check to see if it's one of the UR: endpoints we've defined. 
                        Once it finds a matching route, it then checks to see the mthod of the request and determines which callback function to execute. 
                    If we make a GET request to /api/animals, then the app.get('/api/animals') callback function will execute. 
                        But if it's a POST request, it'll go to the one we just created. 
                    
                    In server.js, update the app.post() method to look like the following code:
                        app.post('/api/animals', (req, res) =>
                        {
                            // req.body is where our incoming content will be
                            console.log(req.body);
                            res.json(req.body);
                        });
                    Again, we're using information that the request object (the req in our callback function) gives us. 
                        Earlier, we used req.query and req.params to look for specific data that our server can send back to the client.
                            With POST requests, we can package up the data, typically as an object, and send it to the server. 
                                The req.body property is where we can access that data on the server side and do something with it. 
                            In this case, we're using console.log() to view the data we're posting to the server and then using res.json() to send the data back to the client. 
                                Obviously this isn't what we typically do with a POST request, but when creating and testing new routes, it's the fastest way to ensure that the data sent from the client gets to the endpoint correctly. 

*   On the job
        Accepting data froma client can be risky. 
        While we expect to receive the type of data we asked for, there is nothing stopping a user from sending incorrect or malicious data to our server.
        For this reason, there are validation libraries that ensure (on the server side) that the data meets certian criteria. 
            It is also why most APIs require that the user must be authenticated to make a POST request, as an access token provided by an authenticated user will let the server confirm that the person making the request is allowed to. 

Test Routes in Insomnia core 
*   Nerd Note  
        The term REST stands for REpresentational State Transfer

*   Middleware is required to complete a POST route, which is used to create a new object, in this case an animal.
        This middleware will instruct Express.js on how to hanlde incoming data.

Add Middleware So the Application Can Accept POST Data 
*   When a client communicates with a server to transfer data, either from client to server (POST) or from server to client (GET), the communication happends over HTTP.
        Unfortunately, HTTP doesn't really understand the type of data we send; it sees raw data that it needs to transfer. 
            This means when we ask for JSON data using a GET request, over server code uses res.json() to provide context to the client receiving the data, so it knows what type of data to interpret the response as. 
                Think back to when we used the response.json() method in the response of a fetch() request. We needed to parse (or convert) the response data to JSON format before we could interface with it. 
                Just as we need to parse data from an API response on the client side, we also need to set up functionality on the server so it can receive data from the client. 
        When we tried our POST request before, it didn't work as intended because we never instructed the server how it should read and parse data to be used. 

*   Parse Incoming Data
        In order for our server to accept incoming data the way we need it to, we need to tell our Express.js to intercept our POST request before it gets to the callback function. 
            At that point, the data will be run through a couple of function to take the raw data transferred over HTTP and convert it to a JSON object. 
            In server.js, add the following code right underneath where we declared the app variable:
                // parse incoming string or array data
                app.use(express.urlencoded({ extended: true }));
                // parse incoming JSON data
                app.use(express.json());
            First we used the app.use() method. 
                This is a method executed by our Express.js server that mounts a function to the server that our requests will pass through before getting to the intended endpoint. 
                    The function we can mount to our server are referred to as middleware. 
                    Middleware function can server many different purposes.
                        Ultimately they allow us to keep our route endpoint callback functions more readable while letting us reuse functionatlity across routes to keep our code DRY.
                        The express.urlended({extended: true}) method is a method built into Express.js.
                            It takes incoming POST data and converts it to key/value pairings that can be accessed in the req.body object.
                            The extended:truee option set inside the method call informs our server that there may be subarray data nested in it as well, so it needs to look as deep into the POST data as possible to parse all of the data correctly.
                        The express.json() method we used takes incoming POST data in the form of JSON and parses it into the req.body JavaScript object. 
                            Both of the methods above are middleware functions that need to be set up every time you create a server that's looking to accept POST data. 
Add Function to Handle Animal Creation
*   In the same way that we created functions to handle our GET route functionatlity, we're going to create a seperate function to handle taking the data from req.body and adding it to our animals.json file.

*   Why is it a good idea to create seperate functionatlity instead of just doing it in the route's callback?
        There are a couple of answers for this, but mainly it'll keep our code a little more organized. 
            Because we've decoupled the functionality from the route's callback in a sense, it gives us the ability to test writing to our animals.json file without having to go through the POST route every time. 

*   Let's create a function called createNewAnimal right below the findById() function in server.js. Add the following code:
        function createNewAnimal(body, animalsArray) {
            console.log(body);
            // our function's main code will go here!

            // return finished code to post route for response
            return body;
        }
    Here, we just created a function that accepts the POST route's req.body value and the array we want to add the data to.
        In this case, that array will be the animalsArray, because the function is for adding a new animal to the catalog. 
            We are going to execute this function from within the app.post() route's callback function and when we do, it'll take the new animal data and add it to the animalsArray we passed in, and then write the new array data to animals.json.
            After saving it, we'll send the data back to the route's callback function so it can finally respond to the requst. 
            Before we do that, however, we need to add something to the new animal's data. 

*   Add an ID to the Animal
        Remember the GET route we created earlier so we can search for a sinle anima;s data by its id property?
            We used req.params.id to conduct that search. 
                This is great because all of our existing animal data has an id property, but what about the new ones we're going to create with the POST route?
                    We could make it so when we send data to the server, the client provides an id value, but that's not great practice. 
                        What happens if the client tries to use an id value that's already taken?
                            Our /api/animals/:id route will only work correctly if all the id values are unique!
                    Instead, we want to generate that id value on the server, as the server can peek into the existing data set in animals.json and know what id values have been used. 
                        Since the animals.json file's data has id values that run in the order of the array's index, we can simply apply the new animal's id value to be one greater than the current highest id value.
                            Let's update our post route's callback to look like the following code:
                                app.post('api/animals', (req, res) => {
                                    // set id based on what the next index of the array will be 
                                    req.body.id = animals.length.toString();

                                    res.json(req.body);
                                });
                            Now when we receive new post data to be added to the animals.json file, we'll take the length property of the animals array (because it's a one-to-one representation of our animals.json file data) and set that as the id fo the new data.
                                Remember, the length property is always going to be one number ahead of the last index of the array so we can avoid any duplicate values. 
                                    This method will only work as long as we don't remove any data from animals.json. 
                                        If we do, the numbers will be thrown off and we'll end up with a duplicate value at some point.

*   Write Animal Data to JSON
        Let's update our post route's callback to send the updated req.body data to createNewAnimal(). Revise the POST code as follows:
            app.post('/api/animals', (req, res) => {
                // set id based on what the next index of the array will be
                req.body.id = animals.length.toString();

                // add animal to json file and animals array in this function
                const animal = createNewAnimal(req.body, animals);

                res.json(animal);
            });

        Once that's in, lets turn our attention to what's happening in createNewAnimal(). Update the function to look like the following code:
            function createNewAnimal(body, animalsArray) {
                const animal = body;
                animalsArray.push(animal);

                return animal;
            }
        Now when we POST a new animal, we'll add it to the imported animals array from the animals.json file.
            There's one problem though. This won't actually add information to animals.json. 
            Keep in mind that whenever we use require() to import data or functionality, it's only reading the data and creating a copy of it to use in server.js.
                So nothing we do with the imported data will ever affect the content of the file from which that data came.
                We'll have to not only use .push() to save the new data in this local server.js copy of our animal data, but we'll also have to import and use the fs library to write that dat to animals.json.
                At the top of server.js, add the following require() statements:
                    const fs = require('fs');
                    const path = require('path');
                So we've seen and used the fs library before, but what's this new one called path?
                    This is another module built into the Node.js API that provides utilities for working with file and directory paths. 
                    It ultimately makes working with our file system a little more predictable, especially when we work with production environments such as Heroku.
                    Let's update our createNewAnimal() function one more time to write to animals.json:
                        function createNewAnimal(body, animalsArray) {
                            const animal = body;
                            animalsArray.push(animal);
                            fs.writeFileSync(
                                path.join(__dirname, './data/animals.json'),
                                JSON.stringify({ animals: animalsArray }, null, 2)
                            );
                            return animal;
                        }
                    Here, we're using the fs.writeFileSync() method, which is the synchronous version of fs.writeFile() and doesn't require a callback function.
                        If we were writing to a much larger data set, the asynchronous version would be better.
                            But because this isn't a large file, it will work for our needs.
                        We want to write to our animals.json file in the subdirectory, so we use the method path.join() to join the value of __dirname, which represents the directory of the file we execute the code in, with the path to the animals.json file.
                            Don't be afraid to test out these methods and console.log() them to see what the result is! 
                                In this case, the path will be from the root of whatever machine this code runs on to the location of our animals.json file.
                    Next, we need to save the JavaScript array data as JSON, so we use JSON.stringify() to convert it.
                        The other two arguements used in the method, null and 2, are means of keeping our data formatted.
                            The null argument means we don't want to edit any of our exisiting data; if we did, we could pass something in there.
                            The 2 indicates we want to create white space between our values to make it more readable. 
                                If we were to leave those two arguments out, the entire animals.json file would work, but it would be really hard to read.
* Add Validation to Our Data
    Validating data is a very important part of building an application because it allows our app to look for values in a consisten fashion without any "what if" scenarios. 
        We can add as much or as little validation as we want - it's completely up to us how strict we need to be. 
    Let's add our own validation function to server.js to make sure everything is okay.
        It is going to take our new animal data from req.body and check if each key not only exists, but that it is also the right type of data. 
        Add the following validateAnimal() function to server.js:
            function validateAnimal(animal) {
                if (!animal.name || typeof animal.name !== 'string') {
                    return false;
                }
                if (!animal.species || typeof animal.species !== 'string') {
                    return false;
                }
                if (!animal.diet || typeof animal.diet !== 'string') {
                    return false;
                }
                if (!animal.personalityTraits || !Array.isArray(animal.personalityTraits)) {
                    return false;
                }
                return true;
            }
        Now, in our POST route's callback before we create the data and add it to the catalog, we'll pass our data through this function. 
            In this case, the animal parameter is going to be the content from req.body, and we're going to run its properties through a series of validation checks.
                If any or them are false, we will return false and not create the animal data.
        Let's update our POST route's callback function now to run this test. Add the following code:
            app.post('/api/animals'), (req, res) => {
                // set id based on what the next index of the array will be
                req.body.id = animals.length.toString();

                // if any data in req.body is incorrect, send 400 error back
                if (!validateAnimal(.req.body)) {
                    res.status(400).send('The animal is not properly formatted.');
                } else {
                    const animal = createNewAnimal (req.body, animals);
                    res.json(animal);
                }
            });
        When we don't send data the server can use or understand, we respond with a 400 error. 
            This indicates to the user that our server doesn't have any problems and we can understand their request, but they incorrectly made the request and we can't allow it to work. 
            The line res.status().send(); is a response method to relay a message to the client making the request.
            We send them an HTTP status code and a message explaining what went wrong. 
                Anything in the 400 range means that it's a user error and not a server error, and the message can help the user understand what wnet wrong on their end. 
        Validating our data is sometimes a tedious process, but it's very important to maintain our data's integrity. 
            As we will see in future work, there are even libraries that can help us do just that!

Set up the New Front End (11.3.3)
*   We use the name public to hold our front-end code because that was the standard naming convention for it when servers were primarily made with Apache web server software.
        You can really call it whatever you want, but typically the terms public or client are the names developers use. 

*   Break Down the Front-End Code (Make sure you know what the front end is doing and what we are trying to acheive with the front end)
        The index.html file will serve as the homepage, with two forms on it to add either a new animal or a zookeeper. 
        The animal.html file is going to allow users to see all of the animal data from our server.
            On load, this page will perform a GET request to receive all animal information from our server.
                There's also a form on the lefthand side that will allow us to get and display a filerted list of animals based on specific data.
        The zookeepers.html page will essentially be the same as animals.html in that we'll eventually receive all information about zookeepers to display, but we don't have that information yet.
        All of these files share a single systel sheet that's already been created for us, and each file has its own JavaScript file.
            These JS files have all of the main functionality handled when it comes to capturing form data and printing it to the page. 
            All that's left is to make the API calls using fetch() functionality!
        There's one more thing before we move on and create the routes to serve this front end. 
            Up until now when we've worked with front-end code, we could simply right-click in the file and select Open In Browser. 
            Unfortunately, we can't do that if we want this page to communicate with our API. So while it may feel natural to open the page that way, we need to make sure that every time we test something on the front end that it is served from http://localhost:3001, or https://<your-heroku-app-name>.herokuapp.com when it's in production.

Create Routes to Server index.html
*   Let's add a route to server.js. The following code can go under the existing routes but above app.listen(), as that should always be last:
        app.get('/', (req, res) => {
            res.sendFile(path.join(__dirname, './public/index.html'));
        });
    So far we've only used routes that have actual names like /api/animals, so where do you think the / route points us to?
        It brings us to the root route of the server. 
            This is the oute used to create a homepage for a server. 
        Unlike most GET and POST routes that deal with creating or returning JSON data, this GET route has just one job to do, and that is to respond with an HTML page to display in the browser. 
            So instead of using res.json(), we're using res.sendFile(), and all we have to do is tell them where to find the file we want our server to read and send back to the client. 
            Notice in the res.sendFile() that we're using the path module again to ensure that we're finding the correct location for the HTML code we want to display in the browser. 
                This way, we know it will work in any server environment. 
            Before Express.js and its res.sendFile() method, the process for serving an HTML page was a little more manual. 
                It involved using the fs module to locate and read the file's content, and then send it back to the client using the simpler res.send() method.
                When we use res.sendFile(), all of that functionality is built into the method. 
                All we need to do is tell them where exactly our file is located and the method will do the rest. 
        When going to http://localhost:3001 in the browser, the webpage will apeear, but you will notice that the URL bar doesn't mention index.html anywhere.
            This is because we made a request to the server's route / and it responded with the HTML. 
                In fact, we could've called the index.html file anything we wanted and it would still be http://localhost:3001. 
                The file itself doesn't ever get to thr browser-only its contents do. 
        Now, onto the big issue. 
            We got our content to display but where's the CSS and JavaScript?
                The <link> and <script> tags are right there in the source HTNL code, so how can they not be present in the browser?

*   Serve Static files
        Whenever we need to ask for another file's information in our HTML file, such as <script src="script.js"> or <link href="style.css">, we're actually making HTTP GET requests for a file's data.
            All of that code lives within our folder structure, but even local requests occur over HTTP.
        So far as our problem goes, our HTML file loads and immediately makes requests to http://localhost:3001/assets/js/script.js and http://localhost:3001/assets/css/sylte.css.
            The problem here is that we never created explicit routes in our Express.js to look for and server those files when requsted.
                Remember, any time we make a request to the server, it looks at every single route we've explicitly created.
                    If it doesn't find a matching route name, it will think that there's something wrong and won't provide a response.
        We need to fix this in our server so it knows that when we ask for front-end resources such as images, client-side JavaScript code, or CSS code, the server knows how to respond. 
            Here's the thing, though—do we have to actually create a route for every front-end asset that we could ever possibly have to use? 
            What happens if we have 10 pages with their own CSS, JavaScript, and images? 
                That's a lot of routes! 
        Rather than creating all of these routes, we can set up some more Express.js middlware that instructs the server to make certian files readibly available and to not gate it behind a server endpoint. 
        Add the following code to the top of the server.js file, near the two app.use() methods:
            app.use(express.static('public'));
        We have added some more middleware to our server and used the express.static() method. The middleware is called static.
            The way it works is that we provide a file path to a location in our application (in this case, the public folder) and instrcut the server to make these files static resources. 
                This means that all of our front-end code can now be accessed without having a specific server endpoint created for it. 
                Every time we create a server that will serve a front end as well as JSON data, we'll always want to use this middleware.

Finish POST Functionality
*   Now, the HTML is being served but nothing happens when we try to add a new animal using the form.
        Let's review script.js  
            It's a fiarly simple setup for this code, as it's only going to handle two different form submissions. 
                We'll focus on the handleAnimalSubmit) function, which is already set up to gather all the data from inputs and organize it as an object that looks like the following code:
                    {
                        name: 'Larry',
                        species: 'Lemur',
                        diet: 'omnivore',
                        personalityTraits: ['hungry']
                    }
*   Previous, what browser API did we use to make HTTP requests from out font-end applications?
        We used the Fetch API's fetch() functionality to make GET requests. 

*   Use Fetch API to POST Data
        By default, the browser's fetch() functionality performs GET requests.
            That's how we've used it in the past, to ask a server for information to use on the front end of our application. 
            This time, we now have data on the front end that needs to be sent, or POSTed, to the back end.
        The Fetch API also supports POST requests, so let's use that to finish our handleAnimalSubmit() function in script.js. Add the following code at the bottom of that function:
            fetch('/api/anims', {
                method: 'POST',
                headers: {
                        Accept: 'application/json',
                        'Content-Type': 'application/json'
                },
                body: JSON.stringify(animalObject)
            })
                .then(response => {
                    if (response.ok) {
                        return response.json();
                    }
                    alert('Error: ' + response.statusText);
                })
                .then(postResponse => {
                    console.log(postResponse);
                    alert('Thank you for adding an animal!');
                });
        So this fetch() function look and works a lot like our previous experience with it when we made GET requests. 
            The big difference now, however, is that we need to add some more information about the request.
            First and most importantly, we have to actually specify what type of request it is and set the method to POST.
                This will allow the request to make it to the proper endpoint in our server.
            Next, we have to tell the request what type of data we're looking to send and then actually provide the data. 
                We set the headers property to inform the request that is going to be JSON data. 
                    That way, we can add stringified JSON data for our animalObject to the body property of the request. 
                        Without these, we would never receive req.body on the server!
        Did you notice that the URL we provide is simply /api/animals? 
            Because the request is coming from the server, we don't have to specify the full URL. 
                This is similar to how we use <script> and <link> to incorporate local files, except that now it's being done through a fetch() call!

Create Routes to Server Other Pages
*   In server.js, add the following route right below the route that serves our index.html page:
        app.get('/animals', (req, res) => {
            res.sendFile(path.join(__dirname, './public/animals.html'));
        });
    This route will take us to /animals. Did you notice how the endpoint here is just /animals?
        This is the second route we've created so far that doesn't have the term api thrown into it. 
            This is intentional, because when we create routes we need to stay organized and set expectations of what type of data is being transferred at that endpoint. 
            We can assume that a route that has the term api in it will deal in transference of JSON data, whereas a more normal-looking endpoint such as /animals should server an HTML page. 
            Express.js isn't opinionated about how routes should be named and organized, so that's a system developers must to create. 
                The naming patterns we've used so far in this project closely follow what you'd typically see in a professional setting.
    We'll get into more details about the front-end code for animals.html soon. 
        First, let's finish up our GET routes and serve up the zookeepers.html file. 
            Again, we don't have any real data or enough information to create API endpoints for zookeeper data just yet, but that shouldn't stop us from getting the actual page up and running!
        Let's add one more route to server.js. You can probably assume how this route will look if you compare it to what we just did for /animals, but it should look like the following code:

            app.get('/zookeepers', (req, res) => {
            res.sendFile(path.join(__dirname, './public/zookeepers.html'));
            });
        There's not much new to explain here. 
            The only thing that's really different is the route we're going to use to display the HTML content from zookeepers.html.

*   Wildcard Routes:
        What happens if the client makes a request for a route that doesn't exist, though? 
            A request to /about, for instance, would result in an error, because there's no route that matches. 
                Users wouldn't be directed to that URL, anyway, but just in case, we can use a wildcard route to catch these kinds of requests.
        In server.js, add the following route underneath the /zookeeper route:
            app.get('*', (req, res) => {
            res.sendFile(path.join(__dirname, './public/index.html'));
            });
        The * will act as a wildcard, meaning any route that wasn't previously defined will fall under this request and will receive the hompage as the response. 
            Thus, requests for /about or /contact or /membership will essentially be the same now.

*   Important  
       The order of your routes matters! 
       The * route should always come last. 
        Otherwise, it will take precedence over named routes, and you won't see what you expect to see on routes like /zookeeper. 

Finish GET Reqests to Serve Page Data
*   Remember that everything still has to go through the server.
        When you want to see a page, you go to the server's route that displays it. 
        This is a paradigm shift in how we're used to doing thing, especially when working with client-side code, but it's the only way to ensure that any communication between both our front and back-end code is happening correctly.

*   Previously, we made a POST request to /api/animals so the form in index.html can submit and create new animal data. 
        Now, we're going to revisit our GET functionality using fetch() and actually GET animal data from /api/animals.
            In the front-end animals.js in the public folder, we need to finish some code that the zoo's front-end designer put together for us. 
            Let's find the getAnimals() function in animals.js and finish it up.
            Currently, the function looks like this:
                const getAnimals = (formData = {}) => {
                    let queryUrl = '/api/animals?';

                    Object.entries(formData).forEach(([key, value]) => {
                        queryUrl += `${key}=${value}&`;
                    });

                    console.log(queryUrl);
                };
        This function is actually capable of making two types of requests; it will depend on how the queryUrl ends up looking. 
            If nothing is passed into formData, then the request will be simply GET /api/animals. This will be what runs on load.
        If you study the code, however, you may find that we call the handleGetAnimalsSubmit() function on form submission. 
            This function will gather all of the form input data and package it as an object to send to the getAnimals() function as the formData argument. 
            From there, the object formData will be passed through the Object.entries() method to create query parameters. 
                Because all that work is done for us, all we have to do is make the request using queryUrl! Let's do that now.
            Add the following code inside the getAnimals() function after the other code:
                fetch(queryUrl)
                .then(response => {
                    if (!response.ok) {
                    return alert('Error: ' + response.statusText);
                    }
                    return response.json();
                })
                .then(animalData => {
                    console.log(animalData);
                    printResults(animalData);
                });
            Does this look more familiar? It should, as it's the standard fetch() usage for making a GET request!
                Remember, when using fetch() we have to check to see if the ok property in the response is true or false. 
                    This is the part that will check for any HTTP status code the signifies an error. 
                        If there's an error, we just alert the user that there's something wrong. 
                        If everything's okay, we still have to use the .json() method to parse our response into readable JSON format.
                        When that's all done, we send our array of animal data to the printResults() function, where it generates cards for each animal and prints them to the page!

*   On the job
        For now, we'll use alert because this is more for the zoo to work with and not the general publc.
            Note that it's considered best practice to display error messages on the page for a better user experience.
                This can be done as a modal or something known as a "toast" dialog box.

Move Animal Functions to a Seperate file
*   We'll start by separating the animals out into a separate folder called lib/. 
        You might recall that lib is short for library, and that its purpose is to store files that will be used by multiple files in your application.
            Go ahead and create a lib/ folder. Then create a file named animals.js in that folder.
    Now move the following functions from server.js into the new animals.js:
        filterByQuery()
        findById()
        createNewAnimal()
        validateAnimal()
    If you cut-and-pasted the functions from server.js to lib/animals.js, your work is not quite done. 
        Whenever we move code from one folder to another, we should always check to ensure that all of the relative paths are accurate.
            If you look in createNewAnimal(), the path to the animals.json has been:
                path.join(__dirname, "./data/animals.json"),
            But lib/animals.js is one level below where server.js is located, so the relative path needs editing. 
                It now needs ./ changed to ../, like so:
                    path.join(__dirname, "../data/animals.json"),
    The updated code in animals.js should look like the following code:

        function filterByQuery(query, animalsArray) {
            let personalityTraitsArray = [];
            let filteredResults = animalsArray;
            if (query.personalityTraits) {
                if (typeof query.personalityTraits === 'string') {
                    personalityTraitsArray = [query.personalityTraits];
                } else {
                    personalityTraitsArray = query.personalityTraits;
                }
                console.log(personalityTraitsArray);
                personalityTraitsArray.forEach(trait => {
                    filteredResults = filteredResults.filter(
                        animal => animal.personalityTraits.indexOf(trait) !== -1
                    );
                });
            }
            if (query.diet) {
                filteredResults = filteredResults.filter(animal => animal.diet === query.diet);
            }
            if (query.species) {
                filteredResults = filteredResults.filter(animal => animal.species === query.species);
            }
            if (query.name) {
                filteredResults = filteredResults.filter(animal => animal.name === query.name);
            }
            return filteredResults;
        }

        function findById(id, animalsArray) {
            const result = animalsArray.filter(animal => animal.id === id)[0];
            return result;
        }

        function createNewAnimal(body, animalsArray) {
            const animal = body;
            animalsArray.push(animal);
            fs.writeFileSync(
                path.join(__dirname, '../data/animals.json'),
                JSON.stringify({animals: animalsArray}, null, 2)
            );
            return animal;
        }

        function validateAnimal(animal) {
            if (!animal.name || typeof animal.name !== 'string') {
                return false;
            }
            if (!animal.species || typeof animal.species !== 'string') {
                return false;
            }
            if (!animal.diet || typeof animal.diet !== 'string') {
                return false;
            }
            if (!animal.personalityTraits || !Array.isArray(animal.personalityTraits)) {
                return false;
            }
            return true;
        }

    Depending on the color scheme you've chosen in VSCode, missing dependencies will often be highlighted in a color that stands out, typically red. 
        Scan the file to see if you can see any missing dependencies.
    The two dependencies of this new lib/animals.js file are fs and path. 
        Be sure to require them at the top of the file, like this:

            const fs = require("fs");
            const path = require("path");

        Lastly, now that all of your functions are in this animals.js file, don't forget to export them using module.exports, just like you've done in the past.
            The exported functions should look like the following code:

                module.exports = {
                    filterByQuery,
                    findById,
                    createNewAnimal,
                    validateAnimal
                };
        Perfect! At this point, we could choose to require the lib functions directly in the server.js file, but this isn't ideal. 
            That would help get some of the code out of server.js, but there would still be a lot of router code in server.js.

        When creating applications, it can be helpful to take a moment to think about the responsibility of every file in the system. Let's do that. 
            We know, from its name alone, that the server.js file should be in charge of starting our server. 
            We also know that the animals functions are already separated out into their own files.
        The biggest remaining responsibility we can move from server.js is the routes.
            Take a look at the following code in server.js:
                app.get('/api/animals', (req, res) => {
                    let results = animals;
                    if (req.query) {
                        results = filter5ByQuery(req.query, results);
                    }
                    res.json(results;)
                });
            There's one dependency here that can't be used in other files.
                The variable that we use to create endpoints, app, is set to express().
                    This means that if we were to move the app routes from server.js to another file, we'd need to make sure we're using the same app the entire time.
                        Let's pretend that we moved our app.get() into its own file.
                            If we were to add const app = express(); at the top of this new file, then app would not be referring to the same app that our server is listening to in server.js
                            It would be a completely new app.
                                So instead of passing around the same app to every file, we're going to use another feature of Express.js called the Router.

*   On the job  
        Many companies have servers with hundreds of possible endpoints. 
            Even if they were to seperate out the lib functions as we've done, that would still mean that the server.js file has an enormous amount of code.
            In these cases, companies modulize their router code as well.

*   What is the purpose of app?
        App represents a single instance of the Express.js server

*   Rewind
        Remember learning about OOP? 
            Every time you call express(), you're creating a new Express.js object. 
            Changing the properties or methods on one Express.js object doesn't affect other Express.js objects you create.

Move Roues to a Seperate file
*   Let's move all of our animals routes into a separate file. 
        Create a new folder named routes/. 
            Inside routes/, create a new folder called apiRoutes/. 
                Then, in apiRoutes, create a new file named animalRoutes.js.
    Move all of the animals API routes from server.js into animalRoutes.js. 
        We need to edit the code, though. 
            Our router function will append /api to each URL, so we must strip /api from each address.
                For instance, instead of this code:
                    app.get('/api/animals', (req, res) => {

                Removing /api will give us this:
                    app.get('/animals', (req, res) => {

        Notice that our app functions are making calls to filterByQuery(), findById(), createNewAnimal(), and validateAnimal(). 
            So, we also need to import those functions that we've moved into lib/animals.js. 
                But we also need to import the animals object that's in data/animals, because those functions make use of it.

        We'll also have to be careful in constructing relative paths to their locations. Remember that ../ is one level higher, so ../../ is two levels higher.
            So, the imports at the top of the file should be:
                const { filterByQuery, findById, createNewAnimal, validateAnimal } = require('../../lib/animals');
                const { animals } = require('../../data/animals');

        The updated animalRoutes.js file should now look like this:
            const { filterByQuery, findById, createNewAnimal, validateAnimal } = require('../../lib/animals');
            const { animals } = require('../../data/animals');

            app.get('/animals', (req, res) => {
                let results = animals;
                if (req.query) {
                    results = filterByQuery(req.query, results);
                }
                res.json(results);
            });

            app.get('/animals/:id', (req, res) => {
                const result = findById(req.params.id, animals);
                if (result) {
                    res.json(result);
                } else {
                    res.send(404);
                }
            });

            app.post('/animals', (req, res) => {
                // set id based on what the next index of the array will be
                req.body.id = animals.length.toString();

                if (!validateAnimal(req.body)) {
                    res.status(400).send('The animal is not properly formatted.');
                } else {
                    const animal = createNewAnimal(req.body, animals);
                    res.json(animal);
                }
            });
        
        Next, as we discussed in the previous section, we cannot use app any longer, because it's defined in the server.js file and cannot be accessed here. 
            Instead, we'll use Router, which allows you to declare routes in any file as long as you use the proper middleware.

        We'll start by adding the following code to the top of animalRoutes.js to start an instance of Router:
            const router = require('express').Router();

        Next, we'll need to change all of the app routes to use router instead. 
        In every routing block in the code, change app to route. 
        For example, the GET route will look like this:

            router.get('/animals', (req, res) => {
                let results = animals;
                if (req.query) {
                    results = filterByQuery(req.query, results);
                }
                res.json(results);
            });

        Last, we should export the router at the end of the file, like this:
            module.exports = router;
        
        The complete animalRoutes.js file should look like this:
            const router = require("express").Router();
            const { filterByQuery, findById, createNewAnimal, validateAnimal, } = require("../../lib/animals");
            const { animals } = require("../../data/animals");

            router.get("/animals", (req, res) => {
                let results = animals;
                if (req.query) {
                    results = filterByQuery(req.query, results);
                }
                res.json(results);
            });

            router.get("/animals/:id", (req, res) => {
                const result = findById(req.params.id, animals);
                if (result) {
                    res.json(result);
                } else {
                    res.send(404);
                }
            });

            router.post("/animals", (req, res) => {
                // set id based on what the next index of the array will be
                req.body.id = animals.length.toString();

                // if any data in req.body is incorrect, send 400 error back
                if (!validateAnimal(req.body)) {
                    res.status(400).send("The animal is not properly formatted.");
                } else {
                    const animal = createNewAnimal(req.body, animals);
                    res.json(animal);
                }
            });

            module.exports = router;

 Great work. You've been very meticulous in modularizing server.js, and your care and attention is paying off. The file is much more manageable already!

We have all of our API routes for animals set up. Now we're going to do the same for the routes that serve HTML. Go ahead and create a new folder inside of routes/ called htmlRoutes/. Within htmlRoutes/, create a new file called index.js.

Move the remaining routing functions from server.js to htmlRoutes/index.js. But let's edit it so that we export each routing call using router, not app. We'll also need to use path.

See if you can figure out how to do this. When you're finished, your code should look like this:

const path = require('path');
const router = require('express').Router();

router.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, '../../public/index.html'));
});

router.get('/animals', (req, res) => {
  res.sendFile(path.join(__dirname, '../../public/animals.html'));
});

router.get('/zookeepers', (req, res) => {
  res.sendFile(path.join(__dirname, '../../public/zookeepers.html'));
});

router.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, '../../public/index.html'));
});

module.exports = router;
Next, we're going to add middleware so that our app knows about the routes in animalRoutes.js. 
    Let's start by adding an index.js file to the apiRoutes/ folder. 
        After you've created the index.js file, add the following code to it:

            const router = require('express').Router();
            const animalRoutes = require('../apiRoutes/animalRoutes');

            router.use(animalRoutes);

            module.exports = router;
        Here we're employing Router as before, but this time we're having it use the module exported from animalRoutes.js. 
            (Note that the .js extension is implied when supplying file names in require()).
        Doing it this way, we're using apiRoutes/index.js as a central hub for all routing functions we may want to add to the application. 
            It may seem like overkill with just one exported module, but as your application evolves, it will become a very efficient mechanism for managing your routing code and keeping it modularized.
            One last thing here: Notice our careful use of relative paths in the require() statement. Always double check these when your files become nested.
        We've added this code so that later, when we add additional routes, they can all be exported from the same file.
        Now go into server.js and update the file to include this at the top:

        const apiRoutes = require('./routes/apiRoutes');
        const htmlRoutes = require('./routes/htmlRoutes');

    The require() statements will read the index.js files in each of the directories indicated. 
        This mechanism works the same way as directory navigation does in a website: If we navigate to a directory that doesn't have an index.html file, then the contents are displayed in a directory listing. 
        But if there's an index.html file, then it is read and its HTML is displayed instead. 
            Similarly, with require(), the index.js file will be the default file read if no other file is provided, which is the coding method we're using here.
    And then add the following right below app.use(express.json()) in server.js:

        app.use('/api', apiRoutes);
        app.use('/', htmlRoutes);

    This is our way of telling the server that any time a client navigates to <ourhost>/api, the app will use the router we set up in apiRoutes. 
        If / is the endpoint, then the router will serve back our HTML routes.           

Test the Functions
*   Now that the animal functions are all in their own files, we can write tests for them without accidentally affecting the Express.js server.
    This is different from the TDD we've done in the past. 
        Rather than having failing/passing tests drive our development, we are building the tests after we've ensured that our application works properly.
        Create a folder named __tests__, and inside that folder, create a file named animals.test.js. 
        Add a unit test for each function in lib/animals.js. 
        When you're finished, your code should look something like the following code:

            const fs = require("fs");
            const {
                filterByQuery,
                findById,
                createNewAnimal,
                validateAnimal,
            } = require("../lib/animals.js");
            const { animals } = require("../data/animals");

            test("creates an animal object", () => {
                const animal = createNewAnimal(
                    { name: "Darlene", id: "jhgdja3ng2" },
                    animals
                );

                expect(animal.name).toBe("Darlene");
                expect(animal.id).toBe("jhgdja3ng2");
            });

            test("filters by query", () => {
                const startingAnimals = [
                    {
                        id: "3",
                        name: "Erica",
                        species: "gorilla",
                        diet: "omnivore",
                        personalityTraits: ["quirky", "rash"],
                    },
                    {
                        id: "4",
                        name: "Noel",
                        species: "bear",
                        diet: "carnivore",
                        personalityTraits: ["impish", "sassy", "brave"],
                    },
                ];

                const updatedAnimals = filterByQuery({ species: "gorilla" }, startingAnimals);

                expect(updatedAnimals.length).toEqual(1);
                });

                test("finds by id", () => {
                    const startingAnimals = [
                        {
                            id: "3",
                            name: "Erica",
                            species: "gorilla",
                            diet: "omnivore",
                            personalityTraits: ["quirky", "rash"],
                        },
                        {
                            id: "4",
                            name: "Noel",
                            species: "bear",
                            diet: "carnivore",
                            personalityTraits: ["impish", "sassy", "brave"],
                        },
                    ];

                    const result = findById("3", startingAnimals);

                    expect(result.name).toBe("Erica");
                });

                test("validates personality traits", () => {
                    const animal = {
                        id: "3",
                        name: "Erica",
                        species: "gorilla",
                        diet: "omnivore",
                        personalityTraits: ["quirky", "rash"],
                    };

                    const invalidAnimal = {
                        id: "3",
                        name: "Erica",
                        species: "gorilla",
                        diet: "omnivore",
                    };

                    const result = validateAnimal(animal);
                    const result2 = validateAnimal(invalidAnimal);

                    expect(result).toBe(true);
                    expect(result2).toBe(false);
                });

        Before you run the tests, make sure that Jest is installed and added to package.json.
        Now make sure that all of your tests pass before moving on by running npm test. 

        There is one problem with running our tests. Open up the animals.json file and look at the last entry. 
        The entry should look like the following:
            {
                "name": "Darlene"
                "id": "jhgdja3ng2"
            }
        That's the same data from our test! 
            Our createAnimal function has a side effect: it also writes to our JSON!
            We don't want to write to the JSON file every time we run npm test
            To avoid this, we'll use a Jest method that we've used in the past: mock().

            When we mock fs, we'll be able to execute methods like fs.writeFileSync() without actually writing anything to a file. 
            This will prevent us from accidentally creating new animals every time we run a test.

            In animals.test.js, add jest.mock('fs'); above the first test.

            Now remove the extra animal from animals.json and run the tests again. As long as you've included the mock(), no extra animals will be created in the JSON file.

Build Dataset and Functionality for zookeepers
*   The zoo has informed us that some of their employees are starting to work remotely and the zoo needs to move their information to the cloud. 
        We can fold that right into the Zoo Keepr application!

        Let's start by creating a new JSON for zookeepers.
            First ensure that you have a zookeepers.json file in the data/ directory.
            Next, create a new file in lib/ for the zookeepers; name it zookeepers.js
        The new lib/zookeepers.js file will look very similar to the lib/animals.js file except that we aren't keeping track of the zookeepers' personality traits (that would be weird!). 
        This should make the filterByQuery() function much easier to write.

Go ahead and add the following code to the lib/zookeepers.js file:

const fs = require("fs");
const path = require("path");

function filterByQuery(query, zookeepers) {
  let filteredResults = zookeepers;
  if (query.age) {
    filteredResults = filteredResults.filter(
      // Since our form data will be coming in as strings, and our JSON is storing
      // age as a number, we must convert the query string to a number to
      // perform a comparison:
      (zookeeper) => zookeeper.age === Number(query.age)
    );
  }
  if (query.favoriteAnimal) {
    filteredResults = filteredResults.filter(
      (zookeeper) => zookeeper.favoriteAnimal === query.favoriteAnimal
    );
  }
  if (query.name) {
    filteredResults = filteredResults.filter(
      (zookeeper) => zookeeper.name === query.name
    );
  }
  return filteredResults;
}

function findById(id, zookeepers) {
  const result = zookeepers.filter((zookeeper) => zookeeper.id === id)[0];
  return result;
}

function createNewZookeeper(body, zookeepers) {
  const zookeeper = body;
  zookeepers.push(zookeeper);
  fs.writeFileSync(
    path.join(__dirname, "../data/zookeepers.json"),
    JSON.stringify({ zookeepers }, null, 2)
  );
  return zookeeper;
}

function validateZookeeper(zookeeper) {
  if (!zookeeper.name || typeof zookeeper.name !== "string") {
    return false;
  }
  if (!zookeeper.age || typeof zookeeper.age !== "number") {
    return false;
  }
  if (
    !zookeeper.favoriteAnimal ||
    typeof zookeeper.favoriteAnimal !== "string"
  ) {
    return false;
  }
  return true;
}

module.exports = {
  filterByQuery,
  findById,
  createNewZookeeper,
  validateZookeeper,
};
Just as you've done for all of the functions in lib/animals.js, write tests for all of the zookeeper functions and make sure they work. 
When you're finished, it should look something like this:

const fs = require("fs");
const {
  filterByQuery,
  findById,
  createNewZookeeper,
  validateZookeeper,
} = require("../lib/zookeepers.js");
const { zookeepers } = require("../data/zookeepers");

jest.mock("fs");
test("creates an zookeeper object", () => {
  const zookeeper = createNewZookeeper(
    { name: "Darlene", id: "jhgdja3ng2" },
    zookeepers
  );

  expect(zookeeper.name).toBe("Darlene");
  expect(zookeeper.id).toBe("jhgdja3ng2");
});

test("filters by query", () => {
  const startingZookeepers = [
    {
      id: "2",
      name: "Raksha",
      age: 31,
      favoriteAnimal: "penguin",
    },
    {
      id: "3",
      name: "Isabella",
      age: 67,
      favoriteAnimal: "bear",
    },
  ];

  const updatedZookeepers = filterByQuery({ age: 31 }, startingZookeepers);

  expect(updatedZookeepers.length).toEqual(1);
});

test("finds by id", () => {
  const startingZookeepers = [
    {
      id: "2",
      name: "Raksha",
      age: 31,
      favoriteAnimal: "penguin",
    },
    {
      id: "3",
      name: "Isabella",
      age: 67,
      favoriteAnimal: "bear",
    },
  ];

  const result = findById("3", startingZookeepers);

  expect(result.name).toBe("Isabella");
});

test("validates age", () => {
  const zookeeper = {
    id: "2",
    name: "Raksha",
    age: 31,
    favoriteAnimal: "penguin",
  };

  const invalidZookeeper = {
    id: "3",
    name: "Isabella",
    age: "67",
    favoriteAnimal: "bear",
  };

  const result = validateZookeeper(zookeeper);
  const result2 = validateZookeeper(invalidZookeeper);

  expect(result).toBe(true);
  expect(result2).toBe(false);
});
Now in apiRoutes/, create another file to handle all zookeeper API routes. See if you can remember what to call that file on your own.

If you guessed zookeeperRoutes.js, you're right. And if you think it should have routing instructions like those we created in animalRoutes.js, that's also right. 

Your code should look like this:

const router = require("express").Router();
const {
  filterByQuery,
  findById,
  createNewZookeeper,
  validateZookeeper,
} = require("../../lib/zookeepers");
const { zookeepers } = require("../../data/zookeepers");

router.get("/zookeepers", (req, res) => {
  let results = zookeepers;
  if (req.query) {
    results = filterByQuery(req.query, results);
  }
  res.json(results);
});

router.get("/zookeepers/:id", (req, res) => {
  const result = findById(req.params.id, zookeepers);
  if (result) {
    res.json(result);
  } else {
    res.send(404);
  }
});

router.post("/zookeepers", (req, res) => {
  req.body.id = zookeepers.length.toString();

  if (!validateZookeeper(req.body)) {
    res.status(400).send("The zookeeper is not properly formatted.");
  } else {
    const zookeeper = createNewZookeeper(req.body, zookeepers);
    res.json(zookeeper);
  }
});

module.exports = router;

Don't forget to go into apiRoutes/index.js and update the file with middleware so that the router uses the new zookeeper routes with the following code:

router.use(require('./zookeeperRoutes'));

Once you believe you've properly set up your API routes, try navigating to http://localhost:3001/api/zookeepers in your browser.

Create Front-End Functionality for zookeepers (11.4.7)
*   Rewind  
        Every time a user navigates to a page, a request is sent to the server for that route. 
            Adding a link to /zookeepers makes the browser request a resource from that route on the server.
            In this case, an HTML file is sent as a response.

*   Take a look at the page served from http://localhost:3001/ again. 
    The HTML already has the form that we need to allow users to create new zookeepers! But is that functionality hooked up in public/assets/js/script.js?

    Let's start by figuring out the ID of the zookeeper form. To find that, look in index.html, which is shown in the following code:

        <form id="zookeeper-form">
            <label for="zookeeper-name" class="form-label">Zookeeper Name</label>
            <input type="text" id="zookeeper-name" class="form-input input" placeholder="Enter Name"
                name="zookeeper-name">

            <label for="age-input" class="form-label input">Age</label>
            <input type="number" id="age-input" class="form-input" placeholder="Enter Age" name="age">

            <label for="favorite-animal" class="form-label">Favorite Animal</label>
            <input type="text" class="form-input input" id="favorite-animal" placeholder="Enter Favorite Animal"
                name="favorite-animal">

            <button class="btn">Add Zookeeper</button>
        </form>

    Did you find it? 
        That's right—it's zookeeper-form.

    Let's add a query selector at the top of public/assets/js/script.js, like this:

        const $zookeeperForm = document.querySelector('#zookeeper-form');
    
    Now we just need to create a new function to handle the zookeeper creation to script.js, just as we've done for animals. Add the following code:

        const handleZookeeperFormSubmit = event => {
            event.preventDefault();

            // get zookeeper data and organize it
            const name = $zookeeperForm.querySelector('[name="zookeeper-name"]').value;
            const age = parseInt($zookeeperForm.querySelector('[name="age"]').value);
            const favoriteAnimal = $zookeeperForm.querySelector('[name="favorite-animal"]').value;

            const zookeeperObj = { name, age, favoriteAnimal };
            console.log(zookeeperObj);
            fetch('api/zookeepers', {
                method: 'POST',
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(zookeeperObj)
            })
                .then(response => {
                    if (response.ok) {
                        return response.json();
                    }
                    alert('Error: ' + response.statusText);
                })
                .then(postResponse => {
                    console.log(postResponse);
                    alert('Thank you for adding a zookeeper!');
                });
        };
    Following that code block, add this above the animalForm event listener that's at the bottom of the file:

        $zookeeperForm.addEventListener('submit', handleZookeeperFormSubmit);

    Now make sure to test the new form and ensure that everything works when we add a zookeeper. You should get an alert.
    Make sure to test the form validation as well by submitting a form that has missing data. Try leaving out out the zookeeper's age. You should get an error alert.

    The homepage works with our new zookeeper routes.
     Now we're going to finish up by adding a zookeeper display page to the application.

    Review your routes/htmlRoutes/index.js file. 
        We previously created the zookeepers route in server.js, then moved it to this index.js file, and revised it to use the router. 
        Double-check that the routes/htmlRoutes/index.js has this code:

            const path = require("path");
            const router = require("express").Router();

            router.get("/", (req, res) => {
                res.sendFile(path.join(__dirname, "../../public/index.html"));
            });

            router.get("/animals", (req, res) => {
                res.sendFile(path.join(__dirname, "../../public/animals.html"));
            });

            router.get("/zookeepers", (req, res) => {
                res.sendFile(path.join(__dirname, "../../public/zookeepers.html"));
            });

            router.get("*", (req, res) => {
                res.sendFile(path.join(__dirname, './public/index.html'));
            });

            module.exports = router;

        Think back to our JSON response from the zookeepers route. 
            Unlike the animals, there's no property on the zookeepers that could be a multiple choice or multi-select, like personalityTraits or diet. 
                We could potentially create a multi-select from the zookeeper's favorite animals, but that could make for a lot of choices.

            Let's update the zookeepers.html so that it includes a search section
            Add the new HTML as a <section> that follows the other two <section> elements that already exist in the code. 
                The HTML for the display area section should now look something like the following code:

                    <section class="my-2 flex-row justify-space-between">
                        <div class="col-12 col-lg-3 bg-dark p-3">
                            <h3 class="text-light">Search For Zookeepers</h3>
                            <form id="zookeeper-form">
                                <label for="name-input" class="form-label">Search by name</label>
                                <input name="name" id="name-input" class="form-input" />
                                <label for="age-input" class="form-label">Search by age</label>
                                <input name="age" id="age-input" class="form-input" type="number" />
                                <button class="btn">Get Zookeepers</button>
                            </form>
                        </div>
                        <div class="col-12 col-lg-9 bg-dark p-3">

                            <div class="flex-row justify-space-between" id="display-area"></div>
                        </div>
                    </section>

                Open public/assets/js/zookeeper.js in your IDE. 
                    Note that it has two functions similar to what is found in the public/assets/js/animals.js front-end file: printResults() and getZookeepers().

                Just as with public/assets/js/animals.js, we want to setup the public/assets/js/zookeeper.js file so that it can handle queries. 
                Let's start by updating getZookeepers(), as shown in the following code:

                    const getZookeepers = (formData = {}) => {
                        let queryUrl = '/api/zookeepers?';

                        Object.entries(formData).forEach(([key, value]) => {
                            queryUrl += `${key}=${value}&`;
                        });

                        fetch(queryUrl)
                            .then(response => {
                                if (!response.ok) {
                                    return alert(`Error: ${response.statusText}`);
                                }
                                return response.json();
                            })
                            .then(zookeeperArr => {
                                console.log(zookeeperArr);
                                printResults(zookeeperArr);
                            });
                    };

                    getZookeepers();

                Great. Take a moment to check that the zookeeper page automatically populates with zookeepers upon page load.
                    we still need to add a function to handle the form data, then pass it as an argument to getZookeepers(). 
                    Create a function called handleGetZookeepersSubmit(). 
                        This function should take the values from the form in zookeepers.html and pass them as an object to getZookeepers().

                    Once you're finished, the code should look like this:

                        const handleGetZookeepersSubmit = event => {
                            event.preventDefault();
                            const nameHTML = $zookeeperForm.querySelector('[name="name"]');
                            const name = nameHTML.value;

                            const ageHTML = $zookeeperForm.querySelector('[name="age"]');
                            const age = ageHTML.value;

                            const zookeeperObject = { name, age };

                            getZookeepers(zookeeperObject);
                        };
                        
                Now we just need to create a reference to the zookeeper form and put a submit event listener on it.

                At the top of the public/assets/js/zookeeper.js file, add this, which will establish a reference to the form:

                    const $zookeeperForm = document.querySelector("#zookeeper-form");

                Then, at the bottom of the file, but—importantly—above the getZookeepers() function call, add a submit event listener on the zookeeper form, like this:

                    $zookeeperForm.addEventListener('submit', handleGetZookeepersSubmit);

                Now try testing the new form by searching for one of the zookeepers by name or age. 
                    You should see that the results are limited to your new query.