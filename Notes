Create an Express.js Server
*   What is Express.js?
        Think back to your time spend working with server-side APIs. Whenever you needed to retrieve data from an API, you would make a request to an endpoint. 
        After a short period of time, the server would return the data to the client in the form of a response. Express.js follows a similar pattern. 

*   What's a server?
        To be considered a server, a machine or program needs to provide some functionatlity to a client. 
        In our case, we want that functionality to be accepting a request and sending back a response. 
        Node.js has built-in libraries that support this functionality, but writing Node.js servers requries significantly more code than using Express.js to do the job. 

*   The first thing we'll do is set up the server so that it's listening for incoming requests. Start by installing Express.js by running the following commands:
        npm init -y //Starts the npm intitialization process and the -y flag is being used to skip the package questionaire and leave defaults. 
        npm i express //You can use npm i as a shortcut for npm install

*   Setting up the server with the server.js file
        Just like any other npm package, we will require Express.js at the top of the file. Add the following code to the top of the file:
            const express = require('express');

        Setting up the server only takes two steps: we need to instantiate the server, then tell it to listen for requres. To instantiate the server, add the following code to server.js:
            const app = express;
                This is all it takes to start Express.js. We assign express() to the app variable so that we can later chain on methods to the Express.js server. 
                Now we just need to use one method to make our server listen. 
                We're going to chain the listen() method onto our server to do it. To do that, add the following code to the end of server.js:

                    app.listen(3001, () => {
                        console.log('API server now on port 3001!');
                    });

                To start the server, use the following command:
                    npm start

*   What's a port?
        To understand ports, let's make an analogy.
            Imagine that a website is like a college campus. A website has an address, referred to as the host. A college campus also has an address.
                The host tells the client where to go, but it doesn't specify exactly where to go. 
                Likewise, if you have the address of the college campus, you don't know exactly which building or classrom to go to.
                The port is lika a building/classroom; it gives the exact destination on the host. 

        If you're browsing the internet, chances are you're visiting the address on one of two ports: 80 or 443.
            80 is typically used for sites that begin with http://, and 443 is used for sites that begin with https://.
            This raises the question: Why are we using 3001 instead of 80 or 443?
                The truth is, there's nothing wrong with running your server on 80 or 443. 
                However, ports with numbers 1024 and under are considered special by the operating system, and often require special permissions (like running the process as an admin.)
                    To avoid these permission restrictions, we chose to run on a poart thit is less restircted, which in this case is 3001, but there are plentys of others available.
                        Port numbers can range from 1024 to 49151!
                            We chose a number around 3000 because it is common practice and farily easy to remember. 


Handle Requests for Animals (data)
*   Let's start by creating a route that the front-end can request data from. Starting by requireing the data by adding the following code at the top of server.js:
        const { animals } = require('./data/animals)
    To add a route, type the following code just before app.listen():
        app.get('/api/animals', (req, res) => {
            res.send('Hello!');
        });
    There are two important takeways from this code:
        1.The first is that the get() method requires two arguments. The first is a string that describes the route the client will have to fetch from.
            The second callback function that will execute every time that route is access with a GET request. 
        2. The second takeaway is that we are using the send() method from the res parameter (short for response) to send the string Hello! to our client. 
    The send() method is great if we want to send short messages, but what if we want to send lots of JSON, like we've seen from APIs? To send JSON, just change send to json.
        We do this to change the headers (i.e., additional metatdata that's sent with every request/response) so that the client know's it's receiving JSON.

    Now we will update the code to use res.json() by changing the second lin in the following code block from res.send('Hello!'); to res.json(animals);:
        app.get('/api/animals', (req, res) => {
            res.json(animals);
        });
            By running the server, the animals.json file would appear at the url http://localhost:3001/api/animals
                There is not a ton of data here, but what if we need info about 5 gorillas and they had 300 animals?
                    Do you remember when you worked with serverside APIs that you were able to specify parameters with your query by using ? or :<parameter>? 
                        Now we are going to create that same functionality with our own server. 
                            To create this query, we'll add another function called filterByQuery().
                                This is going to help us handle differnt kinds of queries. 
                                We will start by extracting the data from after the question mark.
                                    This time we will use the req paramer, which is short for "request" 
                                    Whatever string of query parameters you use on the URL will become JSON, so ?a=111&b=222&c=333 will become:
                                        {
                                            a: "111",
                                            b: "222",
                                            c: "333"
                                        }
                                    Importatnly, if you repeat the same query name with different values, it will become an array in the JSON. So, ?a=111&b=222&b=333 would become:
                                        {
                                            a: "111",
                                            b: ["222", "333"]
                                        }
                                    With that in mind, instead of handling the filter functionatlity inside the .get() callback, we're going to break it out into its own function. 
                                        This will keep our code maintainable and clean. Above the.get(), create a new function called filterByQuery() by adding the following code:
                                            function filterByQuery(query, animalsArray) {
                                                let filteredResults = animalsArray;
                                                if (query.diet) {
                                                    filteredResults = filteredResults.filter(animal => animal.diet === query.diet);
                                                }
                                                if (query.species) {
                                                    filteredResults = filteredResults.filter(animal => animal.species === query.species);
                                                }
                                                if (query.name) {
                                                    filteredResults = filteredResults.filter(animal => animal.name === query.name);
                                                }
                                                return filteredResults;
                                            }
                                        This function will take in re.query as an argument and filter through the animals accordingly returning the new filtered array. 
                                        Go ahead and call the filterByQuery() in the app.get() callback as shown in the following code:
                                            app.get('/api/animals', (req, res) => {
                                                let results = animals;
                                                if (req.query) {
                                                    results = filterByQuery(req.query, results);
                                                }
                                                res.json(resulsts);
                                            });
                                        This code works well querying properties that are strings, but what if we wanted to filter out animals based on their personality traits?
                                            This is different because the personality traits are within an array. To make things more complex, users migh want to filter animals by multipe personality traits at the samte time.
                                                This means we'll have to handle query.personalityTraits differently from the way we handle the other queries. 
                                            How does this process differ from querying for one verus mutliple personality traits?
                                                Adding &personalityTraits=quirky&personalityTraits=rash to the end of the URL in the browser will cause req.query.personalityTraits to become the following array: ['quirky', 'rash'].
                                                However, if we were to query by only one personality trait, like personalityTraits=rash, then req.query.personalityTraits would be the string rash. 
                                                To combat this, modify the filterByQuery() function to handle both cases by adding the following code:
                                                    function filterByQuery(query, animalsArray) {
                                                    let personalityTraitsArray = [];
                                                    // Note that we save the animalsArray as filteredResults here:
                                                    let filteredResults = animalsArray;
                                                    if (query.personalityTraits) {
                                                        // Save personalityTraits as a dedicated array.
                                                        // If personalityTraits is a string, place it into a new array and save.
                                                        if (typeof query.personalityTraits === 'string') {
                                                        personalityTraitsArray = [query.personalityTraits];
                                                        } else {
                                                        personalityTraitsArray = query.personalityTraits;
                                                        }
                                                        // Loop through each trait in the personalityTraits array:
                                                        personalityTraitsArray.forEach(trait => {
                                                        // Check the trait against each animal in the filteredResults array.
                                                        // Remember, it is initially a copy of the animalsArray,
                                                        // but here we're updating it for each trait in the .forEach() loop.
                                                        // For each trait being targeted by the filter, the filteredResults
                                                        // array will then contain only the entries that contain the trait,
                                                        // so at the end we'll have an array of animals that have every one 
                                                        // of the traits when the .forEach() loop is finished.
                                                        filteredResults = filteredResults.filter(
                                                            animal => animal.personalityTraits.indexOf(trait) !== -1
                                                        );
                                                        });
                                                    }
                                                    if (query.diet) {
                                                        filteredResults = filteredResults.filter(animal => animal.diet === query.diet);
                                                    }
                                                    if (query.species) {
                                                        filteredResults = filteredResults.filter(animal => animal.species === query.species);
                                                    }
                                                    if (query.name) {
                                                        filteredResults = filteredResults.filter(animal => animal.name === query.name);
                                                    }
                                                    // return the filtered results:
                                                    return filteredResults;
                                                    }
                                                See the comments in the code. We're revising the filterReulsts array for each trait that we loop through with .forEach().
                                                    Each iteration revises filteredResults to that it only contains animals that possess the indicated trait. 
                                                    At the end of the .forEach() loop, we'll have a filteredResults array that only contains animals that have all the traits we're targeting. 
                                                        Also, while comments may extent the length of your code, they increase its maintainability, not only by you, but by anyone who has to maintain your code going forward. 
                                                        Don't be afraid to add comments to clarify a routine that was tricky to write. 
                                                Now, the filterByQuery() method ensures that query.personalityTraits is always an array before the .forEach() method executes.        

    
Deploy to Heroku
*   We're ready to deploy our application, but we have one problem. GitHub Pages only deploys static sites made up of HTML pages, but we we need to deploy a server.js file that is going to run a Node.js process.
        Therfore, we'll need to use Heroku.
    To get started, created a Heroku account at Heroku.com. Then download the Heroku CLI. The CLI will help us easily get our app deployed, and we won't even need to leave the command line!
    To create a new Heroku application, enter the following command into the terminal:
        heroku create
            You can specify the name of your application by adding <app-name> after heroku create, but it must be a unique name that isn't used anywhere else on Heroku. 
    Just as with GitHub Pages, the deployment steps rely on a Git branch. Reather than pushing to origin main though, we will push to heroku main, as this is a new location for our repository's code to go.
        When we say origin or heroku in our git push commands, they are what's known as the "remote".
        Unfortunately, we cannot simply say git push heroku main when we aren't current in the local main branch.
            Heroku doesn't allow for cross-branch actions the same way GitHub allows. 
                This is a good problem to have, though, as typically we would never want to deploy code to production from a working feature branch. 
                Run the following commands from the command line:
                    git add .
                    git commit -m "Add Heroku"
                    git push heroku main (only if you are currently in main branch)
                        However if you in a different branch it would be:
                            git push heroku <current_git_hub_branch>:main
                Now open the newly created app using the output from the command line in the browser. There will be two items that look like lins, the one we want to open in the browser is the that one that says <your-app-nam>herokuapp.com and not the one that ends with .git
                You can also open the application by entering heroku open from the command line!
                You should receive an Application error! 
                    This happened because we used the hardcoded port of 3001. Heroku apps get server using port 80. We could hardcode our app to use 80, but instead we are going to tell our app to use an environment variable. 
                    When Heroku runs our app, it sets an enviroment variable called process.env.PORT. We're going to tell our app to use that port, if it has been set, and if not, default to port 80.
                        Application served over Heroku as well as most hosts must run on port 80. If the host uses HTTPS, then the port would be set to 443.
                        In server.js, add the following line of code before const app:
                            const PORT = process.env.PORT || 3001;
                                Now go down to where we have our application listening, and replace the hardcoded value with the PORT variable like so:
                                   app.listen(PORT, () => {
                                        console.log(`API server now on port ${PORT}!`);
                                    });

Handle Requests for a Specific Animal (Piece of data)
*   Sometimes we only want one specific animal, rather than an array of all the animals that match a query.
        The req object gives us access to another property for this case, req.params.
        Unlike the query object, the param object needs to be defined in the route path, with <route>/:<parameterName>
        For our sake, create a new GET route for anaimals, after the first Get all route, this time adding :id to the end of the route, as shown in the following code:
            app.get('/api/animals/:id', (req, res) => {
                const result = findById(req.params.id, animals);
                    res.json(result);
            });
        Now that we have multiple routes, we have to pay extra attention to the order of the routes. 
            A param route must come after the other GET route. 
            You may have already noticed that ther's a function called findById() in the callback that looks just like filterByQuery(), except this time we're passing req.params.id.
            Why don't we just use the filterByQuery() function from earlier?
                Well, we could, but we know for certian that this route should only return a single animal, because the id is unique. 
                We also know that there won't be any query on a single animal, so there's no need for all of the other code. 
            Above the two routes, add a function called findById() that takes in the id and array of animals and returns a single animal object, as shown in the following code:
                function findById(id, animalsArray) {
                    const result = animalsArray.filter(animal => animal.id === id)[0];
                    return result;
                }
            Restart your local server with npm start. Then navigate to http://localhost:3001/api/animals/1
                This time, the JSON response is a single object instead of an array. 
                Now let's return to the id route and update it so that if no record exists for the animal being searched for, the client receives a 404 error.
                    Remember that the 404 status code is meant to communicate to the client that the requested resource could not be found.
                    To send this error, we can just send the 404 error code with res.send() like this:
                        app.get('/api/animals/:id', (req, res) => {
                            const result = findById(req.params.id, animals);
                            if (result) {
                                res.json(result);
                            } else {
                                res.send(404);
                            }
                        });
                    We chose to return an error here instead of an empty object or undefined in order to make it clear to the client that the resource they asked for, in this case a specific animal, does not exist. 
                    Note that this is a fairly common practice, but some developer teams might choose other errors to send back to the client, or no error at all.
                    Restart the localhost, and then test the site for 404 functionality by supplying nonsensical IDs, and also check to ensure that actual IDs produce the expected output.
                What is the appropriate use case for req.param vs. req.query?
                    req.query is multifaceted, often combining multiple parameters, whereas req.param is specific to a single property, often intended to retrieve a single record.

Add POST Route to Animals Endpoint (Allows us to create an animal)
*   GET Routes are probably the most common request a developer makes to a server, as we constantly need data to populate the client-side of our web application so users can interact with it. 
    In fact, there are a number of APIs that developers use on a regular basis that only have GET request capabilities.
        So if GET requests serve the purpose of retrieving data from a server and sending it back to the client, how does that get stored on the server in the first place?
        Typically, this is accomplished in one of two ways:
            1. The developer team populates the server with the data manually, because they have access to the server code. 
            2. Users of the app populate the server with data by sending data from the client side of the application to the server. 
                The first way doesn't allow for the type of user interaction that this application requires, so let's take a look at how the second way works. 
                First, we'll set up a route on our server that accepts data to be used or stored server-side.
                    In server.js, add the following code below the two GET routes you've created:
                        app.post('/api/animals', (req, res) => {});
                    Notice that this is just another method of the app object that allows us to create routes, much lik app.get(). 
                        This method doesn't say get though, it says post, which means that we defined a route that listens for POST requests, not GET request. 
                        POST requests differ from GET requests in that they represent the action of a client requesting the server to accept data rather than vice versa. 
                    Also notice the route nbame, /api/animals. Aren't we already using that for a GET request? How does it know which route to use when a request is made?
                        It'll know because of how we form the request. We haven't created a POST request just yet, but think about how we've made GET requests in the past:
                            We make a GET request every time we enter a URL into the browser and press the Enter key to see what will come back in response. 
                                The most common responses we'll see from this is usually JSON - as we've seen already- or a webpage, which we'll see soon.
                            When we use the Fetch API, its defualt request method is GET, as we've seen and used previously. 
                    When we make any type of request to the server, Express.js will go through a couple different phases. 
                        First, it'll take the URL we made a request to and check to see if it's one of the UR: endpoints we've defined. 
                        Once it finds a matching route, it then checks to see the mthod of the request and determines which callback function to execute. 
                    If we make a GET request to /api/animals, then the app.get('/api/animals') callback function will execute. 
                        But if it's a POST request, it'll go to the one we just created. 
                    
                    In server.js, update the app.post() method to look like the following code:
                        app.post('/api/animals', (req, res) =>
                        {
                            // req.body is where our incoming content will be
                            console.log(req.body);
                            res.json(req.body);
                        });
                    Again, we're using information that the request object (the req in our callback function) gives us. 
                        Earlier, we used req.query and req.params to look for specific data that our server can send back to the client.
                            With POST requests, we can package up the data, typically as an object, and send it to the server. 
                                The req.body property is where we can access that data on the server side and do something with it. 
                            In this case, we're using console.log() to view the data we're posting to the server and then using res.json() to send the data back to the client. 
                                Obviously this isn't what we typically do with a POST request, but when creating and testing new routes, it's the fastest way to ensure that the data sent from the client gets to the endpoint correctly. 

*   On the job
        Accepting data froma client can be risky. 
        While we expect to receive the type of data we asked for, there is nothing stopping a user from sending incorrect or malicious data to our server.
        For this reason, there are validation libraries that ensure (on the server side) that the data meets certian criteria. 
            It is also why most APIs require that the user must be authenticated to make a POST request, as an access token provided by an authenticated user will let the server confirm that the person making the request is allowed to. 

Test Routes in Insomnia core 
*   Nerd Note  
        The term REST stands for REpresentational State Transfer

*   Middleware is required to complete a POST route, which is used to create a new object, in this case an animal.
        This middleware will instruct Express.js on how to hanlde incoming data.

Add Middleware So the Application Can Accept POST Data 
*   When a client communicates with a server to transfer data, either from client to server (POST) or from server to client (GET), the communication happends over HTTP.
        Unfortunately, HTTP doesn't really understand the type of data we send; it sees raw data that it needs to transfer. 
            This means when we ask for JSON data using a GET request, over server code uses res.json() to provide context to the client receiving the data, so it knows what type of data to interpret the response as. 
                Think back to when we used the response.json() method in the response of a fetch() request. We needed to parse (or convert) the response data to JSON format before we could interface with it. 
                Just as we need to parse data from an API response on the client side, we also need to set up functionality on the server so it can receive data from the client. 
        When we tried our POST request before, it didn't work as intended because we never instructed the server how it should read and parse data to be used. 

*   Parse Incoming Data
        In order for our server to accept incoming data the way we need it to, we need to tell our Express.js to intercept our POST request before it gets to the callback function. 
            At that point, the data will be run through a couple of function to take the raw data transferred over HTTP and convert it to a JSON object. 
            In server.js, add the following code right underneath where we declared the app variable:
                // parse incoming string or array data
                app.use(express.urlencoded({ extended: true }));
                // parse incoming JSON data
                app.use(express.json());
            First we used the app.use() method. 
                This is a method executed by our Express.js server that mounts a function to the server that our requests will pass through before getting to the intended endpoint. 
                    The function we can mount to our server are referred to as middleware. 
                    Middleware function can server many different purposes.
                        Ultimately they allow us to keep our route endpoint callback functions more readable while letting us reuse functionatlity across routes to keep our code DRY.
                        The express.urlended({extended: true}) method is a method built into Express.js.
                            It takes incoming POST data and converts it to key/value pairings that can be accessed in the req.body object.
                            The extended:truee option set inside the method call informs our server that there may be subarray data nested in it as well, so it needs to look as deep into the POST data as possible to parse all of the data correctly.
                        The express.json() method we used takes incoming POST data in the form of JSON and parses it into the req.body JavaScript object. 
                            Both of the methods above are middleware functions that need to be set up every time you create a server that's looking to accept POST data. 
Add Function to Handle Animal Creation
*   In the same way that we created functions to handle our GET route functionatlity, we're going to create a seperate function to handle taking the data from req.body and adding it to our animals.json file.

*   Why is it a good idea to create seperate functionatlity instead of just doing it in the route's callback?
        There are a couple of answers for this, but mainly it'll keep our code a little more organized. 
            Because we've decoupled the functionality from the route's callback in a sense, it gives us the ability to test writing to our animals.json file without having to go through the POST route every time. 

*   Let's create a function called createNewAnimal right below the findById() function in server.js. Add the following code:
        function createNewAnimal(body, animalsArray) {
            console.log(body);
            // our function's main code will go here!

            // return finished code to post route for response
            return body;
        }
    Here, we just created a function that accepts the POST route's req.body value and the array we want to add the data to.
        In this case, that array will be the animalsArray, because the function is for adding a new animal to the catalog. 
            We are going to execute this function from within the app.post() route's callback function and when we do, it'll take the new animal data and add it to the animalsArray we passed in, and then write the new array data to animals.json.
            After saving it, we'll send the data back to the route's callback function so it can finally respond to the requst. 
            Before we do that, however, we need to add something to the new animal's data. 

*   Add an ID to the Animal
        Remember the GET route we created earlier so we can search for a sinle anima;s data by its id property?
            We used req.params.id to conduct that search. 
                This is great because all of our existing animal data has an id property, but what about the new ones we're going to create with the POST route?
                    We could make it so when we send data to the server, the client provides an id value, but that's not great practice. 
                        What happens if the client tries to use an id value that's already taken?
                            Our /api/animals/:id route will only work correctly if all the id values are unique!
                    Instead, we want to generate that id value on the server, as the server can peek into the existing data set in animals.json and know what id values have been used. 
                        Since the animals.json file's data has id values that run in the order of the array's index, we can simply apply the new animal's id value to be one greater than the current highest id value.
                            Let's update our post route's callback to look like the following code:
                                app.post('api/animals', (req, res) => {
                                    // set id based on what the next index of the array will be 
                                    req.body.id = animals.length.toString();

                                    res.json(req.body);
                                });
                            Now when we receive new post data to be added to the animals.json file, we'll take the length property of the animals array (because it's a one-to-one representation of our animals.json file data) and set that as the id fo the new data.
                                Remember, the length property is always going to be one number ahead of the last index of the array so we can avoid any duplicate values. 
                                    This method will only work as long as we don't remove any data from animals.json. 
                                        If we do, the numbers will be thrown off and we'll end up with a duplicate value at some point.

*   Write Animal Data to JSON
        Let's update our post route's callback to send the updated req.body data to createNewAnimal(). Revise the POST code as follows:
            app.post('/api/animals', (req, res) => {
                // set id based on what the next index of the array will be
                req.body.id = animals.length.toString();

                // add animal to json file and animals array in this function
                const animal = createNewAnimal(req.body, animals);

                res.json(animal);
            });

        Once that's in, lets turn our attention to what's happening in createNewAnimal(). Update the function to look like the following code:
            function createNewAnimal(body, animalsArray) {
                const animal = body;
                animalsArray.push(animal);

                return animal;
            }
        Now when we POST a new animal, we'll add it to the imported animals array from the animals.json file.
            There's one problem though. This won't actually add information to animals.json. 
            Keep in mind that whenever we use require() to import data or functionality, it's only reading the data and creating a copy of it to use in server.js.
                So nothing we do with the imported data will ever affect the content of the file from which that data came.
                We'll have to not only use .push() to save the new data in this local server.js copy of our animal data, but we'll also have to import and use the fs library to write that dat to animals.json.
                At the top of server.js, add the following require() statements:
                    const fs = require('fs');
                    const path = require('path');
                So we've seen and used the fs library before, but what's this new one called path?
                    This is another module built into the Node.js API that provides utilities for working with file and directory paths. 
                    It ultimately makes working with our file system a little more predictable, especially when we work with production environments such as Heroku.
                    Let's update our createNewAnimal() function one more time to write to animals.json:
                        function createNewAnimal(body, animalsArray) {
                            const animal = body;
                            animalsArray.push(animal);
                            fs.writeFileSync(
                                path.join(__dirname, './data/animals.json'),
                                JSON.stringify({ animals: animalsArray }, null, 2)
                            );
                            return animal;
                        }
                    Here, we're using the fs.writeFileSync() method, which is the synchronous version of fs.writeFile() and doesn't require a callback function.
                        If we were writing to a much larger data set, the asynchronous version would be better.
                            But because this isn't a large file, it will work for our needs.
                        We want to write to our animals.json file in the subdirectory, so we use the method path.join() to join the value of __dirname, which represents the directory of the file we execute the code in, with the path to the animals.json file.
                            Don't be afraid to test out these methods and console.log() them to see what the result is! 
                                In this case, the path will be from the root of whatever machine this code runs on to the location of our animals.json file.
                    Next, we need to save the JavaScript array data as JSON, so we use JSON.stringify() to convert it.
                        The other two arguements used in the method, null and 2, are means of keeping our data formatted.
                            The null argument means we don't want to edit any of our exisiting data; if we did, we could pass something in there.
                            The 2 indicates we want to create white space between our values to make it more readable. 
                                If we were to leave those two arguments out, the entire animals.json file would work, but it would be really hard to read.
* Add Validation to Our Data
    Validating data is a very important part of building an application because it allows our app to look for values in a consisten fashion without any "what if" scenarios. 
        We can add as much or as little validation as we want - it's completely up to us how strict we need to be. 
    Let's add our own validation function to server.js to make sure everything is okay.
        It is going to take our new animal data from req.body and check if each key not only exists, but that it is also the right type of data. 
        Add the following validateAnimal() function to server.js:
            function validateAnimal(animal) {
                if (!animal.name || typeof animal.name !== 'string') {
                    return false;
                }
                if (!animal.species || typeof animal.species !== 'string') {
                    return false;
                }
                if (!animal.diet || typeof animal.diet !== 'string') {
                    return false;
                }
                if (!animal.personalityTraits || !Array.isArray(animal.personalityTraits)) {
                    return false;
                }
                return true;
            }
        Now, in our POST route's callback before we create the data and add it to the catalog, we'll pass our data through this function. 
            In this case, the animal parameter is going to be the content from req.body, and we're going to run its properties through a series of validation checks.
                If any or them are false, we will return false and not create the animal data.
        Let's update our POST route's callback function now to run this test. Add the following code:
            app.post('/api/animals'), (req, res) => {
                // set id based on what the next index of the array will be
                req.body.id = animals.length.toString();

                // if any data in req.body is incorrect, send 400 error back
                if (!validateAnimal(.req.body)) {
                    res.status(400).send('The animal is not properly formatted.');
                } else {
                    const animal = createNewAnimal (req.body, animals);
                    res.json(animal);
                }
            });
        When we don't send data the server can use or understand, we respond with a 400 error. 
            This indicates to the user that our server doesn't have any problems and we can understand their request, but they incorrectly made the request and we can't allow it to work. 
            The line res.status().send(); is a response method to relay a message to the client making the request.
            We send them an HTTP status code and a message explaining what went wrong. 
                Anything in the 400 range means that it's a user error and not a server error, and the message can help the user understand what wnet wrong on their end. 
        Validating our data is sometimes a tedious process, but it's very important to maintain our data's integrity. 
            As we will see in future work, there are even libraries that can help us do just that!

